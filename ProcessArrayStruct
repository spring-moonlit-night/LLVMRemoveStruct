/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil  -*- */
/* vim: set tabstop=2 softtabstop=2 shiftwidth=2 expandtab: */

//============================================================================
// Copyright (c) 2011, All Right Reserved, Nimbus Automation Technologies
//
// file:      ESLPass.h
// author:    Zhenghua Gu
// purpose:   The whole backend of ESL (source file)
// revision history:
//============================================================================

#include "target/ESLPass.h"
#include "scheduler/sdc_scheduler.h"

#include "llvm/Transforms/Utils/BasicBlockUtils.h"

#include "tools/optimizer.h"

#include "utility/utility.h"

const float DEFAULT_CLOCK_PERIOD = 10.0;
using namespace std;
using namespace llvm;

namespace esl {
//===----------------------------------------------------------------------===//
//                             ESLPass Implementation
//===----------------------------------------------------------------------===//
bool ESLPass::doInitialization(Module &m) {
  device_ = Device::getDevice();
  assert(device_ != NULL);
  clock_period_ = device_->getClockPeriod();
  if (clock_period_ == 0.0)
    clock_period_ = DEFAULT_CLOCK_PERIOD;
}

void RemoveStruct::changeBitCast() {
  SmallVector<Instruction*,128> *WorkListMove = new SmallVector<Instruction* ,128>();
  SmallVector<Instruction*,128> *ListBitCastLoad = new SmallVector<Instruction* ,128>();
  SmallVector<Instruction*,128> *ListBitCastGetelementPtr = new SmallVector<Instruction* ,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        Instruction* instr = &*itr;
        if (instr->getOpcode() == Instruction::BitCast) {
          if (instr->getNumUses() == 0) { WorkListMove->push_back(instr); }
          else if (instr->getOperand(0)->getType()->getPointerElementType()->isStructTy()
              && instr->getNextNode()->getOpcode() == Instruction::Load) {
            ListBitCastLoad->push_back(instr);
          } else if (instr->getOperand(0)->getType()->getPointerElementType()->isStructTy()
              && instr->getNextNode()->getOpcode() == Instruction::GetElementPtr) {
            ListBitCastGetelementPtr->push_back(instr);
          } else if (instr->getOperand(0)->getType()->isPointerTy()) {
            outs() << "bitcast getType isPointerTy!  " << getLabel(instr) << "\n";
          }
          if (instr->getNumUses() == 0) { WorkListMove->push_back(instr); }
        }
      }
    }
  }

  while (!ListBitCastLoad->empty()) {
     Instruction *instruction = ListBitCastLoad->pop_back_val();
     BitCastLoad(instruction);
   }

  while (!ListBitCastGetelementPtr->empty()) {
     Instruction *instruction = ListBitCastGetelementPtr->pop_back_val();
     BitCastGetelementPtr(instruction);
   }
  while (!WorkListMove->empty()) {
    Instruction *instruction = WorkListMove->pop_back_val();
    instruction->eraseFromParent();
  }
}
// actual_width = num * widht; if the wrong position, flag is false;
void RemoveStruct::structMemoryArrange(vector<int> val_list, map<vector<int>, int> &val_map, Type* val_ty, int actual_width, int &use_width, bool &flag) {
  int step_width = 1;
  int val_width;
  int struct_val_elements = val_ty->getStructNumElements();
  for (int i = 0; i < struct_val_elements; i++) {
    if (val_ty->getStructElementType(i)->isIntegerTy()) {
      val_width = val_ty->getStructElementType(i)->getIntegerBitWidth();
      while (use_width % val_width != 0) {
        use_width += step_width;
      }
      val_list.push_back(i);
      val_map.insert(map<vector<int>, int>::value_type(val_list, use_width));
      val_list.pop_back();
      use_width += val_width;
      outs() << "  " << use_width;
    } else if (val_ty->getStructElementType(i)->isArrayTy()) {
      if (val_ty->getStructElementType(i)->getArrayElementType()->isIntegerTy()) {
        val_list.push_back(i);
        for (int j = 0; j < val_ty->getStructElementType(i)->getArrayNumElements(); ++j) {
          val_width = val_ty->getStructElementType(i)->getArrayElementType()->getIntegerBitWidth();
          while (use_width % val_width != 0) {
            use_width += step_width;
          }
          val_list.push_back(j);
          val_map.insert(map<vector<int>, int>::value_type(val_list, use_width));
          val_list.pop_back();
          use_width += val_width;
          outs() << "  " << use_width;
        }
        val_list.pop_back();
      } else if (val_ty->getStructElementType(i)->getArrayElementType()->isArrayTy()) {
        assert(0);//TODO
      } else if (val_ty->getStructElementType(i)->getArrayElementType()->isStructTy()) {
        assert(0);//TODO
      }

    } else if (val_ty->getStructElementType(i)->isStructTy()) {
      int align = 0;
      BitCastStructAlign(val_ty->getStructElementType(i), align);
      if (use_width % align == 0) {
        val_list.push_back(i);
        structMemoryArrange(val_list, val_map, val_ty->getStructElementType(i), actual_width, use_width, flag);
        val_list.pop_back();
      } else {
        if (actual_width >= use_width && actual_width < (use_width + align - (use_width % align))) {
          flag = false;
        }
        use_width += align - (use_width % align);
        val_list.push_back(i);
        structMemoryArrange(val_list, val_map, val_ty->getStructElementType(i), actual_width, use_width, flag);
        val_list.pop_back();
      }
    } else {
      outs() << "This Type is not considered! " << val_ty->getStructElementType(i) << "\n";
      assert(0);
    }
  }
  int last = 0;
  BitCastStructAlign(val_ty, last);
  if (use_width % last != 0) {
    if (actual_width >= use_width && actual_width < (use_width + last - (use_width % last))) {
      flag = false;
    }
    use_width += last - (use_width % last);
  }
  outs() << "  " << use_width;
}

void RemoveStruct::BitCastGetelementPtr(Instruction* &instr) {
  SmallVector<Instruction*,128> *WorkListDel = new SmallVector<Instruction* ,128>();
  Instruction* getelement_inst = instr->getNextNode();
  assert(getelement_inst->getNumOperands() == 2);
  int bit_width = getelement_inst->getOperand(0)->getType()->getPointerElementType()->getIntegerBitWidth();
  Value* op_1 = getelement_inst->getOperand(1);
  ConstantInt* width;
  int byte_nums;
  if (isa<llvm::ConstantInt>(op_1)) {
    width = llvm::dyn_cast<llvm::ConstantInt>(op_1);
    byte_nums = width->getSExtValue();
  }

  Value* val = instr->getOperand(0);
  Type* val_ty = val->getType()->getPointerElementType();
//  int max_align = 0;
//  BitCastStructAlign(val_ty, max_align);
//  outs() << "max_align  " <<max_align<<"\n";
  int bitcast_bitwidth = instr->getType()->getPointerElementType()->getIntegerBitWidth();
  int actual_width = bitcast_bitwidth * byte_nums;
  bool flag = true;
  int use_width = 0;
//  outs() << "sizeof : " << sizeof(*val_ty) << " *8 = " << sizeof(*val_ty) * 8 << "\n";
  //structMemoryArrange(val_ty, actual_width, use_width, flag);
//  assert (sizeof(*val_ty) * 8 == use_width);
  if (flag == false) {
    outs() <<"bitcast flag : flase " <<"\n";
    for (Value::user_iterator UI = getelement_inst->user_begin(), E =getelement_inst->user_end(); UI != E; ++UI) {
      User *U = *UI;
      assert(isa<Instruction> (U));
      Instruction* CI = dyn_cast<Instruction> (U);
      if (CI->getOpcode() == llvm::Instruction::BitCast) {
        WorkListDel->push_back(CI);
        for (Value::user_iterator UI2 = CI->user_begin(), E2 =CI->user_end(); UI2 != E2; ++UI2) {
          User *U2 = *UI2;
          assert(isa<Instruction> (U2));
          Instruction* CI_2 = dyn_cast<Instruction> (U2);
          if (CI_2->getOpcode() == llvm::Instruction::Load) {
            Value* zero = ConstantInt::get(CI_2->getType(), 0);
            CI_2->replaceAllUsesWith(zero);
            WorkListDel->push_back(CI_2);
          } else if (CI_2->getOpcode() == llvm::Instruction::Store) {
            WorkListDel->push_back(CI_2);
          } else {
            assert(0);
          }
        }
      } else if (CI->getOpcode() == llvm::Instruction::Load) {
        Value* zero = ConstantInt::get(CI->getType(), 0);
        CI->replaceAllUsesWith(zero);
        WorkListDel->push_back(CI);
      } else if (CI->getOpcode() == llvm::Instruction::Store) {
        WorkListDel->push_back(CI);
      } else {
        assert(0);
      }
    }
    WorkListDel->push_back(instr);
    WorkListDel->push_back(instr->getNextNode());
  }
  while (!WorkListDel->empty()) {
    Instruction *instruction = WorkListDel->pop_back_val();
    instruction->eraseFromParent();
  }
}
//TODO
void RemoveStruct::BitCastLoad(Instruction* &instr) {
  Value* val = instr->getOperand(0);
  Type* val_ty = val->getType()->getPointerElementType();
  // Get the list of value's Type in memory
  vector<int> val_list;
  map<vector<int>, Type*> val_map;
  int align = 0;
  BitCastStruct(val_list, val_ty, val_map, align);
  map<vector<int>, Type*>::iterator iter;
  for (iter = val_map.begin(); iter != val_map.end(); iter++) {
    vector<int> temp = iter->first;
    for (std::vector<int>::iterator it = temp.begin(); it != temp.end(); ++it) {
      int a = *it;
      outs() << a << "  ";
    }
    outs() << "\n";
    outs() << "Type list: " << *iter->second << "\n";
    //outs() <<"Type IntegerBitWidth " <<iter->second->getIntegerBitWidth()<<"\n";
  }
  // change BitCast Instruction by the Type list and bitcast_bitwidth
  int bitcast_bitwidth = instr->getType()->getPointerElementType()->getIntegerBitWidth();
  Type* type_zextI = Type::getIntNTy(module_->getContext(), bitcast_bitwidth);
  int val_width = 0;
  int step_width = 1;
  int use_width = 0;
  Instruction* Inst_temp;
  vector<int> begin = val_map.begin()->first;
  int begin_size = begin.size();
  outs()<< getLabel(instr) << "   begin_size:   " << begin_size << "\n";
  for (iter = val_map.begin(); iter != val_map.end(); iter++) {
    val_width = iter->second->getIntegerBitWidth();
    while (use_width % val_width != 0) {
      use_width += step_width;
    }
    use_width += val_width;
    assert(use_width <= bitcast_bitwidth);
    vector<Value *> val_list;
    val_list.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
    vector<int> vec_temp = iter->first;
    assert(begin_size == vec_temp.size());
    for (vector<int>::iterator it = vec_temp.begin(); it != vec_temp.end(); ++it) {
      val_list.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), *it));
    }
    ArrayRef<Value*> list(val_list);
    GetElementPtrInst* ptrInst_new =GetElementPtrInst::CreateInBounds(
             dyn_cast<PointerType> (instr->getOperand(0)->getType())->getElementType(),instr->getOperand(0), list, "", instr);
    llvm::LoadInst* load_GEP = new LoadInst(ptrInst_new, "", instr);
    Instruction* zextI = CastInst::Create(Instruction::ZExt, load_GEP, type_zextI, "", instr);
    Instruction* shlI = BinaryOperator::Create(llvm::Instruction::Shl, zextI,
        ConstantInt::get(type_zextI, use_width-val_width), "", instr);
    if (use_width == val_width) { Inst_temp = shlI; }
    else if (use_width < bitcast_bitwidth) {
      Instruction* xorI = BinaryOperator::Create(llvm::Instruction::Xor, shlI, Inst_temp,"",instr);
      Inst_temp = xorI;
    }
    if (use_width == bitcast_bitwidth) {
      Instruction* xorI = BinaryOperator::Create(llvm::Instruction::Xor, shlI, Inst_temp,"");
      ReplaceInstWithInst(instr->getNextNode(),xorI);
      //ReplaceInstWithInst(B.getInstList(), ++itr, xorI);
      break;
    }
  }
}

void RemoveStruct::BitCastStructAlign(Type* val_ty, int &align) {
  int struct_val_elements = val_ty->getStructNumElements();
  for (int i = 0; i < struct_val_elements; i++) {
    if (val_ty->getStructElementType(i)->isIntegerTy()) {
      if (val_ty->getStructElementType(i)->getIntegerBitWidth() > align) {
        align = val_ty->getStructElementType(i)->getIntegerBitWidth(); }
    } else if (val_ty->getStructElementType(i)->isArrayTy()) {
      BitCastArrayAlign(val_ty->getStructElementType(i), align);
    } else if (val_ty->getStructElementType(i)->isStructTy()) {
      BitCastStructAlign(val_ty->getStructElementType(i), align);
    } else {
      outs() << "This Type is not considered! " << val_ty->getStructElementType(i) << "\n";
      assert(0);
    }
  }
}

void RemoveStruct::BitCastArrayAlign(Type* val_ty, int &align) {
  if (val_ty->getArrayElementType()->isIntegerTy()) {
    if (val_ty->getArrayElementType()->getIntegerBitWidth() > align) {
      align = val_ty->getArrayElementType()->getIntegerBitWidth();
    }
  } else if (val_ty->getArrayElementType()->isArrayTy()) {
    //  array
    BitCastArrayAlign(val_ty->getArrayElementType(), align);
  } else if (val_ty->getArrayElementType()->isStructTy()) {
    BitCastStructAlign(val_ty->getArrayElementType(), align);
  } else {
    outs() << "This Type is not considered! " << val_ty->getArrayElementType() << "\n";
    assert(0);
  }
}

void RemoveStruct::BitCastStruct(vector<int> val_list, Type* val_ty, map<vector<int>, Type*> &val_map, int &align) {
  int struct_val_elements = val_ty->getStructNumElements();
  for (int i = 0; i < struct_val_elements; i++) {
    if (val_ty->getStructElementType(i)->isIntegerTy()) {
      //  int
      val_list.push_back(i);
      val_map.insert(map<vector<int>, Type*>::value_type(val_list, val_ty->getStructElementType(i)));
      if (val_ty->getStructElementType(i)->getIntegerBitWidth() > align) { align = val_ty->getStructElementType(i)->getIntegerBitWidth(); }
      val_list.pop_back();
    } else if (val_ty->getStructElementType(i)->isArrayTy()) {
      //  array
      val_list.push_back(i);
      BitCastArray(val_list, val_ty->getStructElementType(i), val_map, align);
      val_list.pop_back();
    } else if (val_ty->getStructElementType(i)->isStructTy()) {
      //  struct
      val_list.push_back(i);
      BitCastStruct(val_list, val_ty->getStructElementType(i), val_map, align);
      val_list.pop_back();
    } else {
      outs() << "This Type is not considered! " << val_ty->getStructElementType(i) << "\n";
      assert(0);
    }
  }
}


void RemoveStruct::BitCastArray(vector<int> val_list, Type* val_ty, map<vector<int>, Type*> &val_map, int &align) {
  //outs() << "Array Num: " << val_ty->getArrayNumElements() << "\n";
  if (val_ty->getArrayElementType()->isIntegerTy()) {
    //  int
    for (int i = 0; i < val_ty->getArrayNumElements(); ++i) {
      val_list.push_back(i);
      val_map.insert(map<vector<int>, Type*>::value_type(val_list, val_ty->getArrayElementType()));
      if (val_ty->getArrayElementType()->getIntegerBitWidth() > align) { align = val_ty->getArrayElementType()->getIntegerBitWidth(); }
      val_list.pop_back();
    }
  } else if (val_ty->getArrayElementType()->isArrayTy()) {
    //  array
    assert(0);//TODO
    for (int i = 0; i < val_ty->getArrayNumElements(); ++i) {
      val_list.push_back(i);
      BitCastArray(val_list, val_ty->getArrayElementType(), val_map, align);
      val_list.pop_back();
    }
  } else if (val_ty->getArrayElementType()->isStructTy()) {
    //  struct
    assert(0);//TODO
    for (int i = 0; i < val_ty->getArrayNumElements(); ++i) {
      val_list.push_back(i);
      BitCastStruct(val_list, val_ty->getArrayElementType(), val_map, align);
      val_list.pop_back();
    }
  } else {
    outs() << "This Type is not considered! " << val_ty->getArrayElementType() << "\n";
    assert(0);
  }
}

#if 0
void RemoveStruct::memcpySecondConstantExpr(Value* memcpy_from,Value* memcpy_to, Instruction* instr, SmallVector<Instruction*,128> *WorkListLoad){
  //outs() << "The second element of llvm.memcpy is ConstantExpr!" << "\n";
  llvm::ConstantExpr* instrExpr = llvm::dyn_cast<llvm::ConstantExpr>(memcpy_to);
  assert(instrExpr->getOpcode() == llvm::Instruction::BitCast);
  // When (instr)intrinsic->getOperand(1)->getOperand(0) is ConstantStruct
  // memcpy = (1)getelementPtrInst alloca;  (2)StoreInst (global value, (1))
  if (instrExpr->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
    WorkListLoad->push_back(instr);
    llvm::Value* struct_op = instrExpr->getOperand(0);
    if (llvm::isa<llvm::GlobalVariable>(struct_op)) {
      llvm::GlobalVariable* gvar = llvm::dyn_cast<llvm::GlobalVariable>(struct_op);
      //get parameters from GlobalVariable gvar
      if (gvar->hasInitializer()) {
        Value *const_gv = gvar->getInitializer();

        //outs() << "GlobalVariable->getType() " << *const_gv->getType() << "\n";
        if (llvm::isa<llvm::ConstantStruct>(const_gv)) {
          ConstantStruct * global_element = llvm::dyn_cast<llvm::ConstantStruct>(const_gv);
          //int StructNumElements = constExpr->getType()->getPointerElementType()->getStructNumElements();
          int StructNumElements = global_element->getNumOperands();
          for (int i = 0; i < StructNumElements; ++i) {
            //set the address value(i64 0) of list by myself
            vector<Value *> IdxList;
            IdxList.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
            //Twine gvar_addr = Twine(gvar->getName()) + Twine(".addr.");
            llvm::Value* val_gv_op = global_element->getOperand(i);
            IdxList.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
            ArrayRef<Value*> list(IdxList);
            GetElementPtrInst* ptrInst_new =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
                memcpy_from->getType())->getElementType(), memcpy_from, list, "", instr);
            StoreInst *ptr = new StoreInst(val_gv_op, ptrInst_new,instr);
          }
        }
      }
    }
    // When (instr)intrinsic->getOperand(1)->getOperand(0) is ConstantExpr
    // bitcast (%struct* getelementptr ([10 x %struct], [10 x %struct]* @global, i64 0, i64 2) to i8*)
    // %1 = getelementptr ([10 x %struct], [10 x %struct]* @global, i64 0, i64 2, 0)
    // %2 = LoadInst %1
    // %3 = getelementptr alloca i64 0, 0
    // store %2, %3
    else if (llvm::isa<llvm::ConstantExpr>(struct_op)) {
      llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(struct_op);
      if (constExpr->getOpcode() == llvm::Instruction::GetElementPtr) {
        // IdxList of global; allocaList of alloca; Aim to create ArrayRef of GetElementPtrInst
        vector<Value *> IdxList;
        for (int j = 1; j < constExpr->getNumOperands(); ++j) {
          IdxList.push_back(constExpr->getOperand(j));
        }
        vector<Value *> allocaList;
        allocaList.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
        int StructNumElements = constExpr->getType()->getPointerElementType()->getStructNumElements();
        for (int i = 0; i < StructNumElements; ++i){
          IdxList.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
          allocaList.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
          ArrayRef<Value*> list(IdxList);
          GetElementPtrInst* gvInst =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
                 constExpr->getOperand(0)->getType())->getElementType(), constExpr->getOperand(0), list, "", instr);
          LoadInst * loadPtr = new LoadInst(gvInst, "", instr);

          ArrayRef<Value*> allocaArrayRef(allocaList);
          GetElementPtrInst* allocaInst =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
                  memcpy_from->getType())->getElementType(), memcpy_from, allocaArrayRef, "", instr);
          StoreInst *storePtr = new StoreInst(loadPtr, allocaInst, instr);
          IdxList.pop_back();
          allocaList.pop_back();
        }
      }
    }
  } else if (instrExpr->getOperand(0)->getType()->getPointerElementType()->isArrayTy()) {
    // memcpy(i8* %4, i8* bitcast ([10 x %struct.str]* @global to i8*)
    WorkListLoad->push_back(instr);
    Value* arrayVal = instrExpr->getOperand(0);
    if (instrExpr->getNumOperands() == 1) {
      if (llvm::isa<llvm::GlobalVariable>(arrayVal)) {
        llvm::GlobalVariable* gvar = llvm::dyn_cast<llvm::GlobalVariable>(arrayVal);
        if (gvar->hasInitializer()) {
          Value *const_gv = gvar->getInitializer();
          ConstantArray * globalArray = llvm::dyn_cast<llvm::ConstantArray>(const_gv);
          Value * globalFirst = globalArray->getOperand(0);
          if (llvm::isa<llvm::ConstantStruct>(globalFirst)){
            ConstantStruct * structVal = llvm::dyn_cast<llvm::ConstantStruct>(globalFirst);
            int StructNumElements = structVal->getNumOperands();
            for (int i = 0; i < StructNumElements; ++i) {
              vector<Value *> IdxList;
              IdxList.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
              llvm::Value* val_gv_op = structVal->getOperand(i);
              IdxList.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
              ArrayRef<Value*> list(IdxList);
              GetElementPtrInst* ptrInst_new =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
                  memcpy_from->getType())->getElementType(), memcpy_from, list, "", instr);
              StoreInst *ptr = new StoreInst(val_gv_op, ptrInst_new, instr);
            }
          }
        }
      }
    } else {
      outs() << "Didn't consider instrExpr->getNumOperands() > 1!" << "\n";
      assert(0);
    }

  }else {
    outs() << "The ConstantExpr first element is not StructType!" << "\n";
  }
}
#endif

void RemoveStruct::changeMemcpy() {
  SmallVector<Instruction*,128> *WorkListMemcpy = new SmallVector<Instruction*,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        //change IntrinsicInst's memcpy into equivalent instruction
        if (llvm::isa<llvm::IntrinsicInst> (instr)) {
          WorkListMemcpy->push_back(instr);
        }
      }
    }
  }
  while (!WorkListMemcpy->empty()) {
    Instruction *instruction = WorkListMemcpy->pop_back_val();
    memcpy(instruction);
  }
}

#if 1
void RemoveStruct::memcpy(Instruction* &instr) {
  llvm::IntrinsicInst* intrinsic = llvm::dyn_cast<llvm::IntrinsicInst> (instr);
  if (intrinsic->getIntrinsicID() == llvm::Intrinsic::memcpy) {
    if (llvm::isa<llvm::Instruction>(intrinsic->getOperand(0))) {
      Instruction* intrinsic_from = llvm::dyn_cast<Instruction>(intrinsic->getOperand(0));
      Value* memcpy_from;
      if (intrinsic_from->getOpcode() == Instruction::BitCast) {
        //outs() << "get alloca from BitCast Instruction!" << "\n";
        memcpy_from = intrinsic_from->getOperand(0);
      } else if ((intrinsic_from->getOpcode() == Instruction::Alloca)){
        //outs() << "get alloca from Alloca Instruction!" << "\n";
        memcpy_from = intrinsic_from->getOperand(0);
      } else if (intrinsic_from->getOpcode() == Instruction::GetElementPtr) {
        //  %1 = alloca %struct.str,
        //  %2 = getelementptr %struct.str, %struct.str* %1, i64 0, i32 0, i32 0
        memcpy_from = intrinsic_from->getOperand(0);
      }else {
        outs() << "The condition is not considerd!" << "\n";
        assert(0);
      }
      outs() <<  "memcpy_from Type is " << *memcpy_from->getType()<<  " Value is " << getLabel(memcpy_from) << "\n";

      //get global variable(struct_op)  from intrinsic_1
      llvm::Value* memcpy_to = intrinsic->getOperand(1);
      if (memcpy_to->getType()->isStructTy()) {
        outs() << "The second element of llvm.memcpy is Struct Variable!" << "\n";
        assert(0);//TODO
      } else if (llvm::isa<llvm::ConstantExpr>(memcpy_to)){
        memcpyToConstantExpr(memcpy_from, memcpy_to, instr);
      } else if (llvm::isa<llvm::GetElementPtrInst>(memcpy_to)) {
        GetElementPtrInst* intrinsic_to = llvm::dyn_cast<GetElementPtrInst>(memcpy_to);
        if (intrinsic_to->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
          memcpyToGetElementPtrInst(memcpy_from, intrinsic_to, instr);
          // outs()<< "getSourceElementType "<< *intrinsic_to->getSourceElementType()<<"\n";
          // outs()<< "getResultElementType "<<*intrinsic_to->getResultElementType()<<"\n";
        }
      }else {
        outs() << "The second element of llvm.memcpy without Struct!" << "\n";
      }
    }
  }
}
#endif

void RemoveStruct::memcpyToGetElementPtrInst(Value* memcpy_from, GetElementPtrInst* intrinsic_to, Instruction* &instr) {
  SmallVector<Instruction*,128> *WorkListDel = new SmallVector<Instruction*,128>();
  WorkListDel->push_back(instr);
  Instruction* intrinsic_from = llvm::dyn_cast<Instruction>(instr);
  int StructNumElements = intrinsic_to->getSourceElementType()->getStructNumElements();
  Value* struct_val = intrinsic_to->getOperand(0);
  int actual_width = 0;
  bool flag = true;
  int use_width = 0;
  Type* val_ty = struct_val->getType()->getPointerElementType();
  //structMemoryArrange(val_ty, actual_width, use_width, flag);
  for (int i = 0; i < StructNumElements; ++i) {
    //set the address value(i64 0) of list by myself
    vector<Value *> IdxList;
    IdxList.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
    IdxList.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
    ArrayRef<Value*> list(IdxList);
    GetElementPtrInst* from_ptr =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
         memcpy_from->getType())->getElementType(), memcpy_from, list, "", instr);
    GetElementPtrInst* to_ptr =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
        struct_val->getType())->getElementType(), struct_val, list, "", instr);
    LoadInst* load_ptr = new LoadInst(to_ptr, "", instr);
    StoreInst* store_ptr = new StoreInst(load_ptr, from_ptr, instr);
  }
  while (!WorkListDel->empty()) {
    Instruction *instruction = WorkListDel->pop_back_val();
    instruction->eraseFromParent();
  }
}

void RemoveStruct::memcpyToConstantExpr(Value* memcpy_from,Value* memcpy_to, Instruction* &instr) {
  SmallVector<Instruction*,128> *WorkListDel = new SmallVector<Instruction*,128>();

  Value* op_2 = instr->getOperand(2);
  ConstantInt* width;
  int len;
  if (isa<llvm::ConstantInt>(op_2)) {
    width = llvm::dyn_cast<llvm::ConstantInt>(op_2);
    len = width->getSExtValue();
  } else {
    assert(0);
  }
  ConstantExpr* instrExpr = llvm::dyn_cast<llvm::ConstantExpr>(memcpy_to);
  if (instrExpr->getOpcode() == Instruction::BitCast) {
    //  llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* bitcast (%struct.str* @global to i8*), i64 28, i32 4, i1 false)
    if (instrExpr->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
      WorkListDel->push_back(instr);
      int actual_width = 0;
      bool flag = true;
      int use_width = 0;
      int bitcast_width = instrExpr->getType()->getPointerElementType()->getIntegerBitWidth();
      Type* val_ty = instrExpr->getOperand(0)->getType()->getPointerElementType();
      vector<int> val_list;
      map<vector<int>, int> val_map;
      structMemoryArrange(val_list, val_map, val_ty, actual_width, use_width, flag);
      map<vector<int> , int>::iterator iter;
      outs()<<"\n";
      for (iter = val_map.begin(); iter != val_map.end(); iter++) {
        vector<int> temp = iter->first;
        for (std::vector<int>::iterator it = temp.begin(); it != temp.end(); ++it) {
          int a = *it;
          outs() << a << "  ";
        }
        outs() << "\n";
        outs() << "width: " << iter->second << "\n";
        //outs() <<"Type IntegerBitWidth " <<iter->second->getIntegerBitWidth()<<"\n";
      }
      //TODO why sizeof(*val_ty) is 24 not the right 28
      //outs() << "sizeof : " << sizeof(*val_ty) << " * 8 = " << sizeof(*val_ty) * 8 << "\n";
      outs() << "use_width " << use_width << " ; len = " << use_width/8 << "\n";
      assert (use_width == bitcast_width * len);
      Value* struct_val = instrExpr->getOperand(0);
      int StructNumElements = struct_val->getType()->getPointerElementType()->getStructNumElements();
      for (int i = 0; i < StructNumElements; ++i) {
        //set the address value(i64 0) of list by myself
        vector<Value *> IdxList;
        IdxList.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
        IdxList.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
        ArrayRef<Value*> list(IdxList);
        GetElementPtrInst* from_ptr =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
             memcpy_from->getType())->getElementType(), memcpy_from, list, "", instr);
        GetElementPtrInst* to_ptr =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
            struct_val->getType())->getElementType(), struct_val, list, "", instr);
        LoadInst* load_ptr = new LoadInst(to_ptr, "", instr);
        StoreInst* store_ptr = new StoreInst(load_ptr, from_ptr, instr);
      }
    }
  } else if (instrExpr->getOpcode() == Instruction::GetElementPtr) {
    WorkListDel->push_back(instr);
    // %global = alloca %struct.str
    // %1 = getelementptr inbounds %struct.str, %struct.str* %global, i64 0, i32 0
    // call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %1, i8*
    // getelementptr inbounds (%struct.str, %struct.str* @global, i64 0, i32 0), i64 48, i32 8, i1 false)
    if (instrExpr->getOperand(0)->getType()->getPointerElementType()->isStructTy()
        && instr->getPrevNode()->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
      int actual_width = 0;
      bool flag = true;
      int use_width = 0;
      Type* val_ty = instrExpr->getOperand(0)->getType()->getPointerElementType();
      vector<int> val_list;
      map<vector<int>, int> val_map;
      structMemoryArrange(val_list, val_map, val_ty, actual_width, use_width, flag);
      assert (use_width == 8 * len);
      //need to turn to function
      Value* struct_val = instrExpr->getOperand(0);
      int StructNumElements = struct_val->getType()->getPointerElementType()->getStructNumElements();
      for (int i = 0; i < StructNumElements; ++i) {
        //set the address value(i64 0) of list by myself
        vector<Value *> IdxList;
        IdxList.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
        IdxList.push_back( ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
        ArrayRef<Value*> list(IdxList);
        GetElementPtrInst* from_ptr =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
             memcpy_from->getType())->getElementType(), memcpy_from, list, "", instr);
        GetElementPtrInst* to_ptr =GetElementPtrInst::CreateInBounds(dyn_cast<PointerType>(
            struct_val->getType())->getElementType(), struct_val, list, "", instr);
        LoadInst* load_ptr = new LoadInst(to_ptr, "", instr);
        StoreInst* store_ptr = new StoreInst(load_ptr, from_ptr, instr);
      }

    } else if (isa<llvm::ConstantExpr> (instrExpr->getOperand(0))) {
      ConstantExpr* instrExpr_2 = llvm::dyn_cast<llvm::ConstantExpr>(instrExpr->getOperand(0));
      //    %.sroa.2 = alloca [3 x i8], align 1
      //    %.sroa.2.0.sroa_idx = getelementptr inbounds [3 x i8], [3 x i8]* %.sroa.2, i64 0, i64 0
      //    call void @llvm.memcpy.p0i8.p0i8.i64(i8* %.sroa.2.0.sroa_idx, i8* getelementptr inbounds (i8,
      //    i8* getelementptr inbounds (%struct.str, %struct.str* @global, i64 0, i32 0), i64 1), i64 3, i32 1, i1 true)
      if (instrExpr_2->getOpcode() == Instruction::GetElementPtr &&
          instrExpr_2->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
        memcpyToConstantExprGetelementPtr(instrExpr, instrExpr_2);
      }
      // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %.sroa.523.0.sroa_idx, i8*
      // getelementptr inbounds (i8, i8* bitcast (%struct.str* @global to i8*), i64 17), i64 3, i32 1, i1 true)
      else if (instrExpr_2->getOpcode() == Instruction::BitCast &&
          instrExpr_2->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
        memcpyToConstantExprGetelementPtr(instrExpr, instrExpr_2);
      }
    }
  }
  while (!WorkListDel->empty()) {
    Instruction *instruction = WorkListDel->pop_back_val();
    instruction->eraseFromParent();
  }
}
void RemoveStruct::memcpyToConstantExprGetelementPtr(ConstantExpr* instrExpr, ConstantExpr* instrExpr_2) {
  int instrExpr_2_bitwidth =  instrExpr_2->getType()->getPointerElementType()->getIntegerBitWidth();
  Value* instrExpr_1 = instrExpr->getOperand(1);
  ConstantInt* width;
  int num_bitwidth;
  if (isa<llvm::ConstantInt>(instrExpr_1)) {
    width = llvm::dyn_cast<llvm::ConstantInt>(instrExpr_1);
    num_bitwidth = width->getSExtValue();
  } else {
    assert(0);
  }
  int actual_width = num_bitwidth * instrExpr_2_bitwidth;
  bool flag = true;
  int use_width = 0;
//  outs() << "sizeof : " << sizeof(*val_ty) << " *8 = " << sizeof(*val_ty) * 8 << "\n";
  //structMemoryArrange(instrExpr_2->getOperand(0)->getType()->getPointerElementType(), actual_width, use_width, flag);
  if (flag == false) {
      outs() <<"memcpy flag : flase " <<"\n";
  } else {
    assert(0);
  }
}

#if 0
void RemoveStruct::memcpy(Instruction* instr, SmallVector<Instruction*,128> *WorkListLoad) {
  llvm::IntrinsicInst* intrinsic = llvm::dyn_cast<llvm::IntrinsicInst> (instr);
  if (intrinsic->getIntrinsicID() == llvm::Intrinsic::memcpy) {
    assert(intrinsic->getNumOperands() >= 2);
    llvm::Value* intrinsic_0 = intrinsic->getOperand(0);
    llvm::Value* intrinsic_1 = intrinsic->getOperand(1);
  }
}

Value* RemoveStruct::memcpyParm(Value* parameter) {
  if (parameter->getType()->isStructTy()) {
    return parameter;
  } else if (parameter->getType()->isArrayTy()) {
    return parameter;
  }else if (llvm::isa<llvm::Instruction>(parameter)) {
    llvm::Instruction* intrinsic_instr = llvm::dyn_cast<llvm::Instruction>(parameter);
    if (intrinsic_instr->getOpcode() == llvm::Instruction::BitCast) {

    } else if (intrinsic_instr->getOpcode() == llvm::Instruction::GetElementPtr) {

    } else if (intrinsic_instr->getOpcode() == llvm::Instruction::Alloca) {

    }
  } else if (llvm::isa<llvm::ConstantExpr>(parameter)) {
    llvm::ConstantExpr* instrExpr = llvm::dyn_cast<llvm::ConstantExpr>(parameter);
    if (instrExpr->getOpcode() == llvm::Instruction::BitCast) {

    } else if (instrExpr->getOpcode() == llvm::Instruction::GetElementPtr) {

    }
  }
}
#endif


void RemoveStruct::resolveStructVar(Value* &const_gv, GlobalVariable* &gv, string &gv_name) {
  if (llvm::isa<llvm::ConstantStruct>(const_gv)) {
    ConstantStruct * global_element = llvm::dyn_cast<llvm::ConstantStruct>( const_gv);
    int global_nums = global_element->getNumOperands();
    for (int i = 0; i < global_nums; ++i) {
      llvm::Value* val_gv_op = global_element->getOperand(i);
      string layer_name = gv_name + to_string(i);
      //outs() << " layer_name: " << layer_name << "\n";

      assert(llvm::isa<llvm::Constant>(val_gv_op));
      Constant* init = NULL;
      init = dyn_cast<llvm::Constant> (val_gv_op);

      GlobalVariable * gvar_new = new GlobalVariable(*module_,
          val_gv_op->getType(), false, GlobalValue::InternalLinkage, init, "", gv);

      if (keymap_.find(layer_name) == keymap_.end()) {
        outs() << "create a new globalvariable of ConstantStruct & put in keymap. " << "\n";
        keymap_[layer_name] = gvar_new;
      }
    }
  }
}

void RemoveStruct::resolveArrayVar(Value* &const_gv, GlobalVariable* &gv, string &gv_name) {
  if (llvm::isa<llvm::ConstantArray>(const_gv)) {
    ConstantArray * constantArray = llvm::dyn_cast<llvm::ConstantArray>(const_gv);
    outs() << "ArrayVar numbers : " << constantArray->getType()->getArrayNumElements() << "\n";
    if (constantArray->getOperand(0)->getType()->isStructTy()) {
      for (int j = 0; j < constantArray->getOperand(0)->getType()->getStructNumElements(); ++j) {
        std::vector<llvm::Constant*> val;
        ArrayType* arrayType;
        for (int i = 0; i < constantArray->getType()->getArrayNumElements(); ++i) {
          if (isa<llvm::ConstantStruct>(constantArray->getOperand(i))){
            ConstantStruct* constantStruct = llvm::dyn_cast<llvm::ConstantStruct>(constantArray->getOperand(i));
            val.push_back(constantStruct->getOperand(j));
          }
        }
        arrayType = llvm::ArrayType::get(constantArray->getOperand(0)->getOperand(j)->getType(),constantArray->getNumOperands());
        llvm::Constant* init = llvm::ConstantArray::get(arrayType, val);
        string layer_name = gv_name + to_string(j);
        outs() << "ArrayVar layer_name: " << layer_name << "\n";
        GlobalVariable * gvarArray = new GlobalVariable(*module_, init->getType(), false, GlobalValue::InternalLinkage, init, "", gv);
        if (keymap_.find(layer_name) == keymap_.end()) {
          outs() << "create a new globalvariable of ConstantStruct & put in keymap. " << "\n";
          keymap_[layer_name] = gvarArray;
        }
      }
      WorkListGV->push_back(gv);
    }
  }
}

void RemoveStruct::resolveGlobalVar(){
  for (auto gv_iter = module_->global_begin(); gv_iter != module_->global_end(); gv_iter++) {
    GlobalVariable *gv = &*gv_iter;
    //string gv_name = gv->getName().str();
    if (gv->getType()->getPointerElementType()->isAggregateType()) {
      outs() << "gv->getName() " <<gv->getName() << "\n";
      string gv_name = getLabel(gv);
      if (gv->hasInitializer()) {
        Value *const_gv = gv->getInitializer();
        //outs() << " get Initializer Type  " << const_gv->getType()->getTypeID() << "\n";
        if (const_gv->getType()->isStructTy()) {
          outs() << gv_name << " is Struct Type!\n";
          WorkListGV->push_back(gv);
          resolveStructVar(const_gv, gv, gv_name);
        } else if (const_gv->getType()->isArrayTy()) {
          resolveArrayVar(const_gv, gv, gv_name);
          outs() << gv_name << " is Array Type!\n";
        } else if (const_gv->getType()->isVectorTy()) {
          printf(" not consider the VectorTy!\n");
        } else {
          printf(" without struct need to be took apart!\n");
        }
      }
    }
  }
}


vector<Value *> RemoveStruct::valueInstr(const llvm::Instruction* instr) {
  vector<Value *> IdxList;
  for (int i = 0; i < instr->getNumOperands(); ++i) {
    if (i == 0 || i == 1) {
      continue;
    } else if (i == 2) {
      IdxList.push_back(ConstantInt::get(instr->getOperand(1)->getType(), 0));
    } else {
      IdxList.push_back(instr->getOperand(i));
    }
  }
  return IdxList;
}

void RemoveStruct::replaceGlobalVarInstr(){
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        // Case : getelementptr %struct.str, %struct.str* %globalVariable, i64 0, i32 2
        if (instr->getOpcode() == llvm::Instruction::GetElementPtr && isa<llvm::GlobalVariable>(instr->getOperand(0))) {
          if (instr->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
            if (instr->getNumOperands() >= 3) {
              llvm::Value* val_op = instr->getOperand(0);
              llvm::Value* val_op_2 = instr->getOperand(2);
              string variable_name = getLabel(val_op) + getLabel(val_op_2);
              if (keymap_.count(variable_name) > 0) {
                outs() << " GlobalStruct name is " << variable_name << "\n";
                Value* new_var = keymap_[variable_name];
                outs() << "replace GlobalStruct from GetElementPtr! " << "\n";
                vector<Value *> IdxList = valueInstr(instr);
                ArrayRef<Value*> list(IdxList);
                GetElementPtrInst* ptrInst = GetElementPtrInst::CreateInBounds(
                   dyn_cast<PointerType> (new_var->getType())->getElementType(),new_var, list, "");
                ReplaceInstWithInst(B.getInstList(), itr, ptrInst);
              } else {
                outs() << "This Struct case does not match!  "  << getLabel(instr)<< "\n" ;
              }
            }
          }
          // Case : getelementptr [10 x %struct.str], [10 x %struct.str]* @global, i64 0, i64 2, i32 1
          else if (instr->getOperand(0)->getType()->getPointerElementType()->isArrayTy()){
            if (instr->getOperand(0)->getType()->getPointerElementType()->getArrayElementType()->isAggregateType()) {
              if (instr->getOperand(0)->getType()->getPointerElementType()->getArrayElementType()->isStructTy()) {
                if (instr->getNumOperands() == 4) {
                  llvm::Value* val_op = instr->getOperand(0);
                  llvm::Value* val_op_3 = instr->getOperand(3);
                  string variable_name = getLabel(val_op) + getLabel(val_op_3);
                  if (keymap_.count(variable_name) > 0) {
                    outs() << " GlobalArray name is " << variable_name << "\n";
                    Value* new_var = keymap_[variable_name];
                    outs() << "replace GlobalArray from GetElementPtr! " << "\n";
                    vector<Value *> IdxList;
                    for (int i = 0; i < instr->getNumOperands(); ++i) {
                      if (i == 1 || i == 2) {
                        IdxList.push_back(instr->getOperand(i));
                      }
                    }
                    ArrayRef<Value*> list(IdxList);
                    GetElementPtrInst* ptrInst = GetElementPtrInst::CreateInBounds(
                       dyn_cast<PointerType> (new_var->getType())->getElementType(),new_var, list, "");
                    ReplaceInstWithInst(B.getInstList(), itr, ptrInst);
                  }else {
                    outs() << "This Array case does not match!  "  << getLabel(instr)<< "\n" ;
                  }
                } else {
                  outs() << "instr_Array->getNumOperands() > 4!  "  << getLabel(instr)<< "\n" ;
                }
              } else {
                bool flag = instr->getOperand(0)->getType()->getPointerElementType()
                    ->getArrayElementType()->getArrayElementType()->isAggregateType();
                assert(~flag);
              }
            }
          }
        }
      }
    }
  }
}

void RemoveStruct::replaceAllocaRelatedInstrStruct(map<std::string, Value*> alloca_keymap_){
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        if (instr->getOpcode() == llvm::Instruction::GetElementPtr
            && instr->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
          if (instr->getNumOperands() >= 3) {
            llvm::Value* val_op = instr->getOperand(0);
            llvm::Value* val_op_2 = instr->getOperand(2);
            string variable_name= getLabel(val_op) + getLabel(val_op_2);
            //outs() << "variable name " << variable_name << "\n";
            if (alloca_keymap_.count(variable_name) > 0) {
              Value* new_var = alloca_keymap_[variable_name];
              vector<Value *> IdxList = valueInstr(instr);
              ArrayRef<Value*> list(IdxList);
//              GetElementPtrInst* ptrInst_new = GetElementPtrInst::CreateInBounds(
//                   dyn_cast<PointerType> (new_var->getType())->getElementType(),new_var, list, "",instr);
              GetElementPtrInst* ptrInst_new = GetElementPtrInst::CreateInBounds(
                   dyn_cast<PointerType> (new_var->getType())->getElementType(),new_var, list, "");
              ReplaceInstWithInst(B.getInstList(), itr, ptrInst_new);
            }
          }
        }
      }
    }
  }
}

void RemoveStruct::replaceDoubleGetElementPtr(){
  SmallVector<Instruction*,128> *WorkListLoad=new SmallVector<Instruction*,128>();
  SmallVector<Instruction*,128> *WorkListMove=new SmallVector<Instruction*,128>();
  SmallVector<Instruction*,128> *WorkListCI=new SmallVector<Instruction*,128>();
  SmallVector<Instruction*,128> *WorkListPtr=new SmallVector<Instruction*,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        if (instr->getOpcode() == llvm::Instruction::GetElementPtr
            && instr->getNextNode()->getOpcode() == llvm::Instruction::GetElementPtr
            && instr->getNextNode()->getOperand(0) == instr) {
          //To process case : %7 = getelementptr %struct.str* %1, i64 0; %8 = getelementptr %struct.point* %7, i64 0, i32 0
          if (instr->getNumOperands() == 2 && instr->getOperand(0)->getType()->getPointerElementType()->isStructTy()) {
            if (instr->getNumUses() > 0) {WorkListMove->push_back(instr);}
            //llvm::Value* val_op = instr;
            for (Value::user_iterator UI = instr->user_begin(), E =instr->user_end(); UI != E; ++UI) {
              User *U = *UI;
              assert(isa<Instruction> (U));
              Instruction* CI = dyn_cast<Instruction> (U);
              if (CI->getOpcode() == llvm::Instruction::GetElementPtr) {
                WorkListLoad->push_back(CI);
                outs() << "instr->getOperand(0) " << getLabel(instr->getOperand(0)) << "\n";
               //CI->setOperand(0, instr->getOperand(0));
                outs() << "CI->getOperand(0) " << getLabel(CI->getOperand(0)) << "\n";
              }
            }
            while (!WorkListLoad->empty()) {
              Instruction *instruction = WorkListLoad->pop_back_val();
              instruction->setOperand(0, instr->getOperand(0));
            }
          }
          // To process case : %15 = getelementptr [31 x %struct.Tr_3D], [31 x %struct.Tr_3D]* @tr_3ds, i64 0, i64 %14
          //                   %16 = getelementptr  %struct.Tr_3D, %struct.Tr_3D* %15, i64 0, i32 0
          else if (instr->getNumOperands() == 3 && instr->getOperand(0)->getType()->getPointerElementType()->isArrayTy()) {
            if (instr->getNumUses() > 0) {WorkListMove->push_back(instr);}
            for (Value::user_iterator UI = instr->user_begin(), E =instr->user_end(); UI != E; ++UI) {
              vector<Value *> IdxList;
              for (int j = 1; j < instr->getNumOperands(); ++j) {
                IdxList.push_back(instr->getOperand(j));
              }
              User *U = *UI;
              assert(isa<Instruction> (U));
              Instruction* CI = dyn_cast<Instruction> (U);
              if (CI->getOpcode() == llvm::Instruction::GetElementPtr && CI->getNumOperands()>=3) {
                for (int i = 2; i < CI->getNumOperands(); ++i) {
                  IdxList.push_back(CI->getOperand(i));
                }
                ArrayRef<Value*> list(IdxList);
                GetElementPtrInst* ptrInst =GetElementPtrInst::CreateInBounds(
                    instr->getOperand(0)->getType()->getPointerElementType(),
                    instr->getOperand(0), list, "");
                WorkListCI->push_back(CI);
                WorkListPtr->push_back(ptrInst);
              }
            }
          }
        }
      }
    }
  }
  while (!WorkListCI->empty()) {
    Instruction *CI = WorkListCI->pop_back_val();
    Instruction *Ptr = WorkListPtr->pop_back_val();
    ReplaceInstWithInst(CI, Ptr);
  }
  while (!WorkListMove->empty()) {
    Instruction *instruction = WorkListMove->pop_back_val();
    instruction->eraseFromParent();
  }
}

void RemoveStruct::replaceAllocaStruct(Instruction* allocaInst,SmallVector<Instruction*,128> *WorkListGetEStore){

  //To split %struct %x, i64 0 into  x,0,0
  for (Value::user_iterator UI = allocaInst->user_begin(), E =allocaInst->user_end(); UI != E; ++UI) {
    User *alloca_user = *UI;
    assert(isa<Instruction> (alloca_user));
    Instruction* alloca_user_inst = dyn_cast<Instruction> (alloca_user);
    //just to find the specific instruction which has 2 getNumOperands and NextNode Store
    if (alloca_user_inst->getNumOperands() == 2) {
      if (alloca_user_inst->getNextNode()->getOpcode() == llvm::Instruction::Store){
        WorkListGetEStore->push_back(alloca_user_inst);
        WorkListGetEStore->push_back(alloca_user_inst->getNextNode());
        Value* struct_val = alloca_user_inst->getNextNode()->getOperand(0);
        int struct_val_num = struct_val->getType()->getStructNumElements();
        if (isa<llvm::ConstantStruct>(struct_val)){
          ConstantStruct * struct_element = llvm::dyn_cast<llvm::ConstantStruct>(struct_val);
          for (int i = 0; i < struct_val_num; ++i) {
            llvm::Value* val_gv_op = struct_element->getOperand(i);
            //set the address value(i64 0) of list by myself
            vector<Value *> IdxList;
            IdxList.push_back(ConstantInt::get(Type::getInt64Ty(module_->getContext()), 0));
            IdxList.push_back(ConstantInt::get(Type::getInt32Ty(module_->getContext()), i));
            ArrayRef<Value*> list(IdxList);
            GetElementPtrInst* ptrInst_new =GetElementPtrInst::CreateInBounds(
               dyn_cast<PointerType> (alloca_user_inst->getOperand(0)->getType())->getElementType(),
               alloca_user_inst->getOperand(0), list, "", alloca_user_inst);
            StoreInst *ptr = new StoreInst(val_gv_op, ptrInst_new,alloca_user_inst);
          }
        }
      }
    }
  }
}


void RemoveStruct::replaceAllocaInstrStruct() {
  SmallVector<Instruction*,128> *WorkListLoad=new SmallVector<Instruction*,128>();
  SmallVector<Instruction*,128> *WorkListMove=new SmallVector<Instruction*,128>();
  SmallVector<Instruction*,128> *WorkListGetEStore=new SmallVector<Instruction*,128>();
  map<std::string /*Key*/, Value * /*Value*/> alloca_keymap_;
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        if (llvm::isa<llvm::AllocaInst>(instr)) {
          if (instr->getType()->getPointerElementType()->isStructTy()) {
            WorkListLoad->push_back(instr);
            llvm::AllocaInst* allocaInst = llvm::dyn_cast<llvm::AllocaInst>(instr);
            outs() << "getAllocatedType Type : " << *allocaInst->getAllocatedType() <<"\n";
            //To replace allocaInst into subVariables
            int StructNumElements = allocaInst->getType()->getPointerElementType()->getStructNumElements();
            for (int i = 0; i < StructNumElements; ++i) {
              Type* StructElementType = allocaInst->getType()->getPointerElementType()->getStructElementType(i);
              string variable_name = getLabel(instr) + to_string(i);
              outs() << "alloca_struct variable name " << variable_name << "\n";
              AllocaInst* alloca = new AllocaInst(StructElementType, 0, "", instr);
              if (alloca_keymap_.find(variable_name) == alloca_keymap_.end()) {
                alloca_keymap_[variable_name] = alloca;
              }
            }
            //To split %struct %x, i64 0 into  x,0,0
            replaceAllocaStruct(allocaInst, WorkListGetEStore);
          }
        }
      }
    }
  }
  replaceAllocaRelatedInstrStruct(alloca_keymap_);
  replaceDoubleGetElementPtr();
  //To remove getelementptr & store instructions
  while (!WorkListGetEStore->empty()) {
    Instruction *instr = WorkListGetEStore->pop_back_val();
    assert(instr->getNumUses() == 0);
    instr->eraseFromParent();
  }
  //TO remove all uses of instruction and itself alloca
  while (!WorkListLoad->empty()) {
    Instruction *instruction = WorkListLoad->pop_back_val();
    //To remove all uses of instruction alloca
    for (Value::user_iterator UI = instruction->user_begin(), E =instruction->user_end(); UI != E; ++UI) {
      User *U = *UI;
      assert(isa<Instruction> (U));
      Instruction* CI = dyn_cast<Instruction> (U);
      WorkListMove->push_back(CI);
    }
    while (!WorkListMove->empty()) {
      Instruction *instr_move = WorkListMove->pop_back_val();
      instr_move->eraseFromParent();
    }
    instruction->eraseFromParent();
  }
  alloca_keymap_.clear();
}

void RemoveStruct::replaceAllocaRelatedInstrArray(map<std::string, Value*> alloca_keymap_){
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        if (instr->getOpcode() == llvm::Instruction::GetElementPtr
            && instr->getOperand(0)->getType()->getPointerElementType()->isArrayTy()) {
          if (instr->getNumOperands() == 4) {
            llvm::Value* val_op = instr->getOperand(0);
            llvm::Value* val_op_3 = instr->getOperand(3);
            string variable_name= getLabel(val_op) + getLabel(val_op_3);
            //outs() << "variable name " << variable_name << "\n";
            if (alloca_keymap_.count(variable_name) > 0) {
              Value* new_var = alloca_keymap_[variable_name];
              vector<Value *> IdxList;
              for (int i = 0; i < instr->getNumOperands(); ++i) {
                if (i == 1 || i == 2) {
                  IdxList.push_back(instr->getOperand(i));
                }
              }
              ArrayRef<Value*> list(IdxList);
              GetElementPtrInst* ptrInst = GetElementPtrInst::CreateInBounds(
                   dyn_cast<PointerType> (new_var->getType())->getElementType(),new_var, list, "");
              ReplaceInstWithInst(B.getInstList(), itr, ptrInst);
            }
          }
        }
      }
    }
  }
}

void RemoveStruct::replaceAllocaInstrArray() {
  SmallVector<Instruction*,128> *WorkListLoad=new SmallVector<Instruction*,128>();
  SmallVector<Instruction*,128> *WorkListMove=new SmallVector<Instruction*,128>();
  map<std::string /*Key*/, Value * /*Value*/> alloca_keymap_;
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        if (llvm::isa<llvm::AllocaInst>(instr) && instr->getType()->getPointerElementType()->isArrayTy()
            && instr->getType()->getPointerElementType()->getArrayElementType()->isAggregateType()){
          if (instr->getType()->getPointerElementType()->getArrayElementType()->isStructTy()){
            WorkListLoad->push_back(instr);
            llvm::AllocaInst* allocaInst = llvm::dyn_cast<llvm::AllocaInst>(instr);
            int ArrayNumElements = allocaInst->getType()->getPointerElementType()->getArrayNumElements();
            int StructNumElements = allocaInst->getType()->getPointerElementType()->getArrayElementType()->getStructNumElements();
            for (int i = 0; i < StructNumElements; ++i){
              Type* StructElementType = allocaInst->getType()->getPointerElementType()->getArrayElementType()->getStructElementType(i);
              ArrayType* arrayType = llvm::ArrayType::get(StructElementType, ArrayNumElements);
              string variable_name = getLabel(instr) + to_string(i);
              outs() << "alloca_array variable name " << variable_name << "\n";
              AllocaInst* alloca = new AllocaInst(arrayType, 0, "", instr);
              if (alloca_keymap_.find(variable_name) == alloca_keymap_.end()) {
                alloca_keymap_[variable_name] = alloca;
              }
              replaceAllocaRelatedInstrArray(alloca_keymap_);
            }
          }
        }
      }
    }
  }
  //TODO some case may not be considered!
  //TO remove all uses of instruction and itself alloca
  while (!WorkListLoad->empty()) {
    Instruction *instruction = WorkListLoad->pop_back_val();
    //To remove all uses of instruction alloca
    for (Value::user_iterator UI = instruction->user_begin(), E =instruction->user_end(); UI != E; ++UI) {
      User *U = *UI;
      assert(isa<Instruction> (U));
      Instruction* CI = dyn_cast<Instruction> (U);
      WorkListMove->push_back(CI);
    }
    while (!WorkListMove->empty()) {
      Instruction *instr_move = WorkListMove->pop_back_val();
      instr_move->eraseFromParent();
    }
    instruction->eraseFromParent();
  }
  alloca_keymap_.clear();
}

void RemoveStruct::splitLoad() {
  SmallVector<Instruction*,128> *WorkListLoad=new SmallVector<Instruction*,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        if (instr->getOpcode() == llvm::Instruction::Load) {
          if (isa<llvm::ConstantExpr> (instr->getOperand(0))) {
            llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(0));
            if (constExpr->getOpcode() == llvm::Instruction::GetElementPtr) {
              //Process this case: "load i64, i64* getelementptr"
              WorkListLoad->push_back(instr);
            } else if(constExpr->getOpcode() == llvm::Instruction::BitCast) {
              //Process this case: "load i64, i64* bitcast"
              WorkListLoad->push_back(instr);
            }
          }
        }
      }
    }
  }
  while (!WorkListLoad->empty()) {
    Instruction *instr = WorkListLoad->pop_back_val();
    llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(0));
    Instruction* get_inst = constExpr->getAsInstruction();
    get_inst->insertBefore(instr);
    //outs() << "getE_inst->getNumUses() " << constExpr->getNumUses() << "\n";
    instr->setOperand(0, get_inst);
  }
}

void RemoveStruct::splitStore() {
  SmallVector<Instruction*,128> *WorkListStore=new SmallVector<Instruction*,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        if (instr->getOpcode() == llvm::Instruction::Store) {
          if (isa<llvm::ConstantExpr> (instr->getOperand(1))){
            llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(1));
            if (constExpr->getOpcode() == llvm::Instruction::GetElementPtr) {
              //Process this case: "store i64 %1, i64* getelementptr"
              WorkListStore->push_back(instr);
            }
          }
        }
      }
    }
  }
  while (!WorkListStore->empty()) {
    Instruction *instr = WorkListStore->pop_back_val();
    llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(1));
    Instruction* get_inst = constExpr->getAsInstruction();
    get_inst->insertBefore(instr);
    //outs() << "getE_inst->getNumUses() " << constExpr->getNumUses() << "\n";
    instr->setOperand(1, get_inst);
  }
}

void RemoveStruct::splitBitCast(){
  SmallVector<Instruction*,128> *WorkListBitCast=new SmallVector<Instruction*,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        //Process this cast: "bitcast %struct.point* getelementptr"
        if (instr->getOpcode() == llvm::Instruction::BitCast) {
          if (isa<llvm::ConstantExpr> (instr->getOperand(0))) {
            llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(0));
            if (constExpr->getOpcode() == llvm::Instruction::GetElementPtr) {
              //Type *Ty = instr->getType()->getPointerElementType();
              WorkListBitCast->push_back(instr);
            }
          }
        }
      }
    }
  }
  while (!WorkListBitCast->empty()) {
    Instruction *instr = WorkListBitCast->pop_back_val();
    llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(0));
    Instruction* get_inst = constExpr->getAsInstruction();
    get_inst->insertBefore(instr);
    //outs() << "getE_inst->getNumUses() " << constExpr->getNumUses() << "\n";
    instr->setOperand(0, get_inst);
  }
}

void RemoveStruct::splitGetelementPtr() {
  SmallVector<Instruction*,128> *WorkListGetelementPtr=new SmallVector<Instruction*,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        //Process this cast: getelementptr inbounds i8, i8* bitcast (%struct.str* @global to i8*), i64 14
        if (instr->getOpcode() == llvm::Instruction::GetElementPtr) {
          if (isa<llvm::ConstantExpr> (instr->getOperand(0))) {
            llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(0));
            if (constExpr->getOpcode() == llvm::Instruction::BitCast) {
              //Type *Ty = instr->getType()->getPointerElementType();
              WorkListGetelementPtr->push_back(instr);
            }
          }
        }
      }
    }
  }
  while (!WorkListGetelementPtr->empty()) {
    Instruction *instr = WorkListGetelementPtr->pop_back_val();
    llvm::ConstantExpr* constExpr = llvm::dyn_cast<llvm::ConstantExpr>(instr->getOperand(0));
    Instruction* get_inst = constExpr->getAsInstruction();
    get_inst->insertBefore(instr);
    //outs() << "getE_inst->getNumUses() " << constExpr->getNumUses() << "\n";
    instr->setOperand(0, get_inst);
  }
}

void RemoveStruct::removeLifetime() {
  SmallVector<Instruction*,128> *WorkListDel=new SmallVector<Instruction*,128>();
  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
    Function &F = *f;
    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
      llvm::BasicBlock &B = *b;
      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
        llvm::Instruction* instr = &*itr;
        //change IntrinsicInst's memcpy into equivalent instruction
        if (llvm::isa<llvm::IntrinsicInst>(instr)) {
          llvm::IntrinsicInst* intrinsic = llvm::dyn_cast<llvm::IntrinsicInst>(instr);
          if (intrinsic->getIntrinsicID() == llvm::Intrinsic::lifetime_start) {
            WorkListDel->push_back(instr);
          } else if (intrinsic->getIntrinsicID() == llvm::Intrinsic::lifetime_end){
            WorkListDel->push_back(instr);
          }
        }
      }
    }
  }
  while (!WorkListDel->empty()) {
    Instruction *instruction = WorkListDel->pop_back_val();
    instruction->eraseFromParent();
  }
}

//void RemoveStruct::NoUseLoad() {
//  for (Module::iterator f = module_->begin(), FE = module_->end(); f != FE; ++f) {
//    Function &F = *f;
//    for (Function::iterator b = F.begin(); b != F.end(); ++b) {
//      llvm::BasicBlock &B = *b;
//      for (llvm::BasicBlock::iterator itr = B.begin(); itr != B.end(); ++itr) {
//        llvm::Instruction* instr = &*itr;
//        if (llvm::isa<llvm::LoadInst> (instr)) {
//          LoadInst * a = llvm::dyn_cast<llvm::LoadInst>(instr);
//          Value* b = a->getPointerOperand();
//          outs() << b->hasValueHandle()<< "$$$ " << a->getPointerAddressSpace() << "\n";
//        }
//      }
//    }
//  }
//}

void RemoveStruct::changeBC(){
  splitLoad();
  splitStore();
  splitBitCast();
  splitGetelementPtr();
  removeLifetime();
  changeBitCast();
  changeMemcpy();
}

void RemoveStruct::replaceStructInstr(){

  replaceDoubleGetElementPtr();
  replaceGlobalVarInstr();
  //next to process constant struct variable
  replaceAllocaInstrStruct();
  replaceAllocaInstrArray();
  while (!WorkListGV->empty()) {
    GlobalVariable *gv = WorkListGV->pop_back_val();
    outs() << "gv: " << getLabel(gv) << "\n";
    gv->eraseFromParent();
  }
}

void RemoveStruct::replaceStruct(){
  resolveGlobalVar();
  replaceStructInstr();
  keymap_.clear();
}

void RemoveStruct::RemoveStructMain(){
  changeBC();
  outs() << "Start to loop structVariable!  " << "\n";
//  while (findStruct()){
//    replaceStruct();
//  }
//  replaceStruct();
}


bool
